// Generated by CoffeeScript 1.6.3
(function() {
  var Styles, debug, error, log, nib, path, warn, _ref;

  nib = require('nib');

  path = require('path');

  _ref = require('./../utils/log-util'), log = _ref.log, debug = _ref.debug, warn = _ref.warn, error = _ref.error;

  module.exports = Styles = (function() {
    var AMD_WRAPPER;

    function Styles() {}

    Styles.POLVO = null;

    Styles.NAME = 'styles';

    Styles.TYPE = 'style';

    Styles.EXT = /(\.css)$/m;

    AMD_WRAPPER = "// Assembled by Polvo\ndefine(['require', 'exports', 'module'], function(require, exports, module)\n{\n  var style = module.exports = document.createElement('style');\n  var head = document.getElementsByTagName('head')[0];\n\n  style.id = '~id';\n  style.appendChild(document.createTextNode(\"~css\"));\n  head.insertBefore(style, head.lastChild);\n\n  return style;\n});";

    Styles.compile = function(file, after_compile, compile_dependents) {
      var clean, reg, style, wrapped;
      if (/^_/m.test(file.name)) {
        if (compile_dependents) {
          this.compile_dependents(file);
        }
        return;
      }
      reg = /^\s*(?!\/\/)\@import\s+url\s*\((?:'|")([^"']+)(?:'|")\s*\);?/mg;
      clean = file.raw.replace(reg, '');
      clean = clean.replace(/\n|\r/g, '');
      style = clean.replace(/"/g, '\\"');
      wrapped = AMD_WRAPPER.replace('~css', style);
      wrapped = wrapped.replace(/~id/g, file.id);
      return after_compile(wrapped);
    };

    Styles.translate_ext = function(filepath) {
      return filepath.replace(this.EXT, '.js');
    };

    Styles.strip_ext = function(filepath) {
      return filepath.replace(this.EXT, '');
    };

    Styles.compile_dependents = function(file) {
      var abs_path, compile_dependents, f, files, has_import_reg, import_dir, import_dir_parts, import_file, import_path, match, parent_dir_parts, part, reg, tentacle, tree, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _results;
      files = [];
      _ref1 = this.POLVO.tentacles;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        tentacle = _ref1[_i];
        _ref2 = tentacle.trees;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          tree = _ref2[_j];
          files = files.concat(tree.files);
        }
      }
      has_import_reg = /^\s*(?!\/\/)\@import/mg;
      _results = [];
      for (_k = 0, _len2 = files.length; _k < _len2; _k++) {
        f = files[_k];
        if (f.type !== this.TYPE) {
          continue;
        }
        if (!has_import_reg.test(f.raw)) {
          continue;
        }
        reg = /^\s*(?!\/\/)\@import\s+url\s*\((?:'|")([^"']+)(?:'|")\s*\)\s*;?/mg;
        _results.push((function() {
          var _results1;
          _results1 = [];
          while ((match = reg.exec(f.raw)) != null) {
            import_path = match[1];
            import_dir = path.dirname(import_path);
            import_file = path.basename(import_path);
            parent_dir_parts = (path.dirname(f.absolute_path)).split('/');
            import_dir_parts = import_dir.split('/');
            while ((part = import_dir_parts[0]) === '..') {
              import_dir_parts.shift();
              parent_dir_parts.pop();
            }
            abs_path = path.normalize([parent_dir_parts.join('/'), import_dir_parts.join('/'), import_file].join('/'));
            if (("" + abs_path + ".css") === file.absolute_path) {
              compile_dependents = /^_/m.test(f.name);
              _results1.push(f.compile_to_disk(compile_dependents));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };

    return Styles;

  })();

}).call(this);

/*
//@ sourceMappingURL=style.map
*/
