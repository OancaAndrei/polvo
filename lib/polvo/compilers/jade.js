// Generated by CoffeeScript 1.6.2
(function() {
  var Jade, debug, error, fs, jade, log, path, warn, _ref;

  path = require('path');

  fs = require('fs');

  jade = require('jade');

  _ref = require('./../utils/log-util'), log = _ref.log, debug = _ref.debug, warn = _ref.warn, error = _ref.error;

  module.exports = Jade = (function() {
    var AMD_WRAPPER;

    function Jade() {}

    Jade.NAME = 'jade';

    Jade.TYPE = 'template';

    Jade.EXT = /(\.jade)$/m;

    AMD_WRAPPER = "// Compiled by Polvo, using Jade\ndefine(['require', 'exports', 'module'], function(require, exports, module){\n  return exports.module = ~code\n});";

    Jade.compile = function(file, after_compile, compile_dependents) {
      var compiled, err, wrapped;

      if (/^_/m.test(file.name)) {
        if (compile_dependents) {
          this.compile_dependents(file);
        }
        return;
      }
      try {
        compiled = jade.compile(file.raw, {
          filename: file.absolute_path,
          client: true,
          compileDebug: true
        });
      } catch (_error) {
        err = _error;
        return error(err.message);
      }
      wrapped = AMD_WRAPPER.replace('~code', compiled.toString());
      return after_compile(wrapped);
    };

    Jade.fetch_helpers = function() {
      var filepath;

      filepath = path.join(__dirname, '..', '..', '..', 'node_modules', 'jade');
      filepath = path.join(filepath, 'runtime.js');
      return fs.readFileSync(filepath, 'utf-8');
    };

    Jade.translate_ext = function(filepath) {
      return filepath.replace(this.EXT, '.js');
    };

    Jade.strip_ext = function(filepath) {
      return filepath.replace(this.EXT, '');
    };

    Jade.compile_dependents = function(file) {
      var abs_path, all_import_reg, f, files, has_import_reg, import_dir, import_dir_parts, import_file, import_path, match, parent_dir_parts, part, tentacle, tree, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _results;

      files = [];
      _ref1 = this.POLVO.tentacles;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        tentacle = _ref1[_i];
        _ref2 = tentacle.trees;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          tree = _ref2[_j];
          files = files.concat(tree.files);
        }
      }
      has_import_reg = /^[^\/]*include\s/m;
      _results = [];
      for (_k = 0, _len2 = files.length; _k < _len2; _k++) {
        f = files[_k];
        if (/^_/m.test(f.name)) {
          continue;
        }
        if (f.type !== this.TYPE) {
          continue;
        }
        if (!has_import_reg.test(f.raw)) {
          continue;
        }
        all_import_reg = /^[^\/]*(?:include\s)(.+)/gm;
        _results.push((function() {
          var _results1;

          _results1 = [];
          while ((match = all_import_reg.exec(f.raw)) != null) {
            import_path = match[1];
            import_dir = path.dirname(import_path);
            import_file = path.basename(import_path);
            parent_dir_parts = (path.dirname(f.absolute_path)).split('/');
            import_dir_parts = import_dir.split('/');
            while ((part = import_dir_parts[0]) === '..') {
              import_dir_parts.shift();
              parent_dir_parts.pop();
            }
            abs_path = path.normalize([parent_dir_parts.join('/'), import_dir_parts.join('/'), import_file].join('/'));
            if (("" + abs_path + ".jade") === file.absolute_path) {
              _results1.push(f.compile_to_disk());
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };

    return Jade;

  })();

}).call(this);

/*
//@ sourceMappingURL=jade.map
*/
