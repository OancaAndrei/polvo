// Generated by CoffeeScript 1.6.2
(function() {
  var ArrayUtil, FnUtil, Loader, MinifyUtil, Optimizer, StringUtil, VendorsJS, debug, error, fs, fsu, log, path, util, warn, _ref;

  path = require('path');

  fs = require('fs');

  util = require('util');

  fsu = require('fs-util');

  FnUtil = require('../utils/fn-util');

  ArrayUtil = require('../utils/array-util');

  StringUtil = require('../utils/string-util');

  MinifyUtil = require('../utils/minify-util');

  Loader = require('./optimizer/loader');

  VendorsJS = require('./optimizer/vendors-js');

  _ref = require('../utils/log-util'), log = _ref.log, debug = _ref.debug, warn = _ref.warn, error = _ref.error;

  module.exports = Optimizer = (function() {
    var missing;

    Optimizer.prototype.loader = null;

    Optimizer.prototype.vendors_js = null;

    function Optimizer(polvo, cli, config, tentacle) {
      this.polvo = polvo;
      this.cli = cli;
      this.config = config;
      this.tentacle = tentacle;
      this.loader = new Loader(this.polvo, this.cli, this.config, this.tentacle, this);
      this.vendors_js = new VendorsJS(this.polvo, this.cli, this.config, this.tentacle, this);
    }

    Optimizer.prototype.copy_vendors_to_release = function(all, specific, log_time) {
      return this.vendors_js.copy_to_release(all, specific, log_time);
    };

    Optimizer.prototype.write_amd_loader = function(release_mode) {
      var paths;

      paths = this.copy_vendors_to_release();
      return this.loader.write_amd_loader(paths, release_mode);
    };

    Optimizer.prototype.optimize = function() {
      if (this.config.optimize.merge != null) {
        return this.merge_everything();
      }
      return log('Optimizing project...');
    };

    Optimizer.prototype.merge_files = function(after_merge) {
      var buffer, file, _i, _len, _ref1,
        _this = this;

      buffer = [];
      _ref1 = this.reorder(this.tentacle.get_all_files());
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        file = _ref1[_i];
        file.compile_to_str((function(code) {
          return buffer.push(code);
        }), true);
      }
      return buffer.join('\n');
    };

    Optimizer.prototype.merge_everything = function() {
      var buffer, location, _ref1;

      log('Merging files..'.grey);
      buffer = "//---------------------------------------- amd loader\n\n\n";
      buffer += this.loader.get_amd_loader(true);
      buffer += "//---------------------------------------- vendors\n\n\n";
      buffer += this.vendors_js.merge_to_str() + '\n\n';
      buffer += "//---------------------------------------- files\n\n\n";
      buffer += this.merge_files() + '\n';
      buffer += "//---------------------------------------- amd initializer\n\n\n";
      buffer += "require( ['" + this.config.main_module + "'] );";
      if ((_ref1 = this.config.optimize) != null ? _ref1.minify : void 0) {
        log('Minifying..'.grey);
        buffer = MinifyUtil.min(buffer);
      }
      location = path.join(this.config.destination, this.config.index);
      fs.writeFileSync(location, buffer);
      location = location.replace(this.polvo.basepath, '');
      return log('Project merged at: ' + location.green);
    };

    missing = {};

    Optimizer.prototype.reorder = function(files, cycling) {
      var bc, dep, dependency, dependency_index, file, file_index, found, id, index, not_found, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2;

      if (cycling == null) {
        cycling = false;
      }
      if (cycling === false) {
        this.missing = {};
      }
      for (file_index = _i = 0, _len = files.length; _i < _len; file_index = ++_i) {
        file = files[file_index];
        if (!file.dependencies.length && !file.baseclasses.length) {
          continue;
        }
        _ref1 = file.dependencies;
        for (index = _j = 0, _len1 = _ref1.length; _j < _len1; index = ++_j) {
          dep = _ref1[index];
          if (dep.vendor) {
            continue;
          }
          id = dep.id;
          dependency = ArrayUtil.find(files, {
            'id': id
          });
          if (dependency != null) {
            dependency_index = dependency.index;
          }
          if (dependency_index < file_index && (dependency != null)) {
            continue;
          }
          if (dependency != null) {
            if (ArrayUtil.has(dependency.item.dependencies, {
              'id': file.id
            })) {
              file.dependencies.splice(index, 1);
              warn("Circular dependency found between ".yellow + id.grey.bold + " and ".yellow + file.id.grey.bold);
              continue;
            } else {
              files.splice(file_index, 0, dependency.item);
              files.splice(dependency.index + 1, 1);
              this.reorder(files, true);
              break;
            }
          } else if (this.missing[id] !== true) {
            this.missing[id] = true;
            file.dependencies.push(id);
            file.dependencies.splice(index, 1);
            warn(("" + 'Dependency'.yellow + " " + id.bold.grey + " ") + ("" + 'not found for file'.yellow + " ") + file.id.grey.bold);
          }
        }
        file_index = ArrayUtil.find(files, {
          'id': file.id
        });
        file_index = file_index.index;
        _ref2 = file.baseclasses;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          bc = _ref2[_k];
          found = ArrayUtil.find(files, bc, "classname");
          not_found = (found === null) || (found.index > file_index);
          if (not_found && !this.missing[bc]) {
            this.missing[bc] = true;
            warn("Base class ".yellow + ("" + bc + " ").bold.grey + "not found for class ".yellow + ("" + file.classname + " ").bold.grey + "in file ".yellow + file.id.bold.grey);
          }
        }
      }
      return files;
    };

    return Optimizer;

  })();

}).call(this);

/*
//@ sourceMappingURL=optimizer.map
*/
