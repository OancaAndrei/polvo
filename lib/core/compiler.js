// Generated by CoffeeScript 1.10.0
var _, argv, auto_reload, build_js_split, compilers, config, debug, dirs, error, files, fs, fsu, get_split_base_dir, helpers_path, humanize, info, io_path, loader, loader_path, log_compiled, logger, minify, path, prefix, reloader_path, server, source_maps_header, sourcemaps, split_loader, split_loader_path, sufix, upath, warn, zlib;

_ = require('lodash');

fs = require('fs');

zlib = require('zlib');

fsu = require('fs-util');

path = require('path');

upath = require('upath');

humanize = require('humanize');

files = require('./files');

server = require('./server');

argv = require('../cli').argv;

dirs = require('../utils/dirs');

config = require('../utils/config');

minify = require('../utils/minify');

sourcemaps = require('../utils/sourcemaps');

logger = require('../utils/logger')('core/compiler');

error = logger.error, warn = logger.warn, info = logger.info, debug = logger.debug;

log_compiled = logger.file.compiled;

prefix = ";(function(){";

helpers_path = upath.join(dirs.root, 'src', 'core', 'helpers');

loader_path = upath.join(helpers_path, 'loader.js');

loader = fs.readFileSync(loader_path, 'utf-8');

loader = loader.replace('~ALIASES', JSON.stringify(config.alias));

split_loader_path = upath.join(helpers_path, 'split.loader.js');

split_loader = fs.readFileSync(split_loader_path, 'utf-8');

io_path = upath.join(dirs.root, 'node_modules', 'socket.io', 'node_modules');

io_path = upath.join(io_path, 'socket.io-client', 'socket.io.js');

reloader_path = loader_path.replace('loader.js', 'reloader.js');

auto_reload = fs.readFileSync(io_path, 'utf-8');

auto_reload += fs.readFileSync(reloader_path, 'utf-8');

source_maps_header = "/*\n//@ sourceMappingURL=data:application/json;charset=utf-8;base64,~MAP\n*/";

sufix = '})()';

compilers = {};

exports.build = function() {
  compilers = {};
  exports.build_js(true);
  return exports.build_css(true);
};

exports.release = function(done) {
  var after, j, js, jss, len, pending, uncompressed;
  jss = exports.build_js();
  exports.build_css();
  pending = 0;
  after = function() {
    if (--pending === 0) {
      return typeof done === "function" ? done() : void 0;
    }
  };
  if (config.minify.js) {
    for (j = 0, len = jss.length; j < len; j++) {
      js = jss[j];
      pending++;
      uncompressed = fs.readFileSync(upath.join(js));
      fs.writeFileSync(js, minify.js(uncompressed.toString()));
      exports.notify(js, after);
    }
  }
  if (config.minify.css && fs.existsSync(config.output.css)) {
    pending++;
    uncompressed = fs.readFileSync(config.output.css);
    fs.writeFileSync(config.output.css, minify.css(uncompressed.toString()));
    return exports.notify(config.output.css, after);
  }
};

exports.build_js = function(notify) {
  var all, base64_maps, base_folder, boot, buffer, comp, comp_name, each, helper, helpers, i, j, js, k, l, len, len1, len2, linesnum, m, merged, offset, p, ref, relative_paths, split_paths, src_maps, start, tmp, v;
  files.files = _.sortBy(files.files, 'filepath');
  all = _.filter(files.files, {
    output: 'js'
  });
  if (!all.length) {
    return;
  }
  if (config.output.js == null) {
    error('JS not saved, you need to set the js output in your config file');
    return;
  }
  if (argv.split) {
    split_paths = build_js_split(all, notify);
  } else {
    split_paths = [];
  }
  helpers = {};
  merged = [];
  offset = 0;
  for (j = 0, len = all.length; j < len; j++) {
    each = all[j];
    if (each.is_partial) {
      continue;
    }
    js = each.wrapped;
    linesnum = js.split('\n').length;
    merged.push(js);
    each.source_map_offset = offset;
    offset += linesnum;
    comp = each.compiler;
    comp_name = comp.name;
    if ((helpers[comp_name] == null) && ((helper = typeof comp.fetch_helpers === "function" ? comp.fetch_helpers() : void 0) != null)) {
      helpers[comp_name] || (helpers[comp_name] = helper);
    }
  }
  helpers = (function() {
    var results;
    results = [];
    for (k in helpers) {
      v = helpers[k];
      results.push(v);
    }
    return results;
  })();
  merged = merged.join('\n');
  buffer = '';
  if (argv.server && !argv.release) {
    buffer += "\n// POLVO :: AUTORELOAD\n";
    buffer += auto_reload;
  }
  buffer += prefix;
  buffer += '\n// POLVO :: HELPERS\n';
  buffer += helpers;
  buffer += "\n// POLVO :: LOADER\n";
  buffer += loader;
  if (!argv.split) {
    buffer += "\n// POLVO :: MERGED FILES\n";
  }
  start = buffer.split('\n').length;
  for (l = 0, len1 = all.length; l < len1; l++) {
    each = all[l];
    each.source_map_offset += start;
  }
  src_maps = sourcemaps.assemble(all);
  if (!argv.split) {
    buffer += merged;
  }
  buffer += "\n// POLVO :: INITIALIZER\n";
  boot = "require('" + config.boot + "');";
  if (argv.split) {
    relative_paths = split_paths.slice(0);
    for (i = m = 0, len2 = relative_paths.length; m < len2; i = ++m) {
      p = relative_paths[i];
      base_folder = (config != null ? (ref = config.server) != null ? ref.root : void 0 : void 0) || path.dirname(config.output.js);
      relative_paths[i] = p.replace(base_folder, '');
    }
    tmp = split_loader.replace('~SRCS', JSON.stringify(relative_paths));
    tmp = tmp.replace('~BOOT', boot);
    buffer += tmp;
  } else {
    buffer += boot;
  }
  if (!argv.split) {
    buffer += "\n";
    base64_maps = sourcemaps.encode_base64(src_maps);
    buffer += source_maps_header.replace('~MAP', base64_maps);
  }
  buffer += sufix;
  fs.writeFileSync(config.output.js, buffer);
  if (!argv.release) {
    server.reload('js');
  }
  if (notify) {
    exports.notify(config.output.js);
  }
  return [config.output.js].concat(split_paths);
};

exports.build_css = function(notify) {
  var all, each, j, len, merged;
  files.files = _.sortBy(files.files, 'filepath');
  all = _.filter(files.files, {
    output: 'css'
  });
  if (!all.length) {
    return;
  }
  if (config.output.css == null) {
    error('CSS not saved, you need to set the css output in your config file');
    return;
  }
  merged = [];
  for (j = 0, len = all.length; j < len; j++) {
    each = all[j];
    if (each.is_partial) {
      continue;
    }
    merged.push(each.compiled);
  }
  merged = merged.join('\n');
  fs.writeFileSync(config.output.css, merged);
  server.reload('css');
  if (notify) {
    return exports.notify(config.output.css);
  }
};

exports.notify = function(filepath, done) {
  var fsize;
  fsize = humanize.filesize(fs.statSync(filepath).size);
  if (!argv.release) {
    log_compiled(filepath + " (" + fsize + ")");
    return typeof done === "function" ? done() : void 0;
  }
  return zlib.gzip(fs.readFileSync(filepath, 'utf-8'), function(err, gzip) {
    var gsize;
    fs.writeFileSync(filepath + '.tmp.gzip', gzip);
    gsize = humanize.filesize(fs.statSync(filepath + '.tmp.gzip').size);
    log_compiled(filepath + " (" + fsize + ") (" + gsize + " gzipped)");
    fs.unlinkSync(filepath + '.tmp.gzip');
    return typeof done === "function" ? done() : void 0;
  });
};

get_split_base_dir = function(files) {
  var all, buffer, f, file, j, l, len, len1, len2, m, part, ref, start, tokens;
  buffer = [];
  tokens = {};
  for (j = 0, len = files.length; j < len; j++) {
    file = files[j];
    ref = file.filepath.split(path.sep);
    for (l = 0, len1 = ref.length; l < len1; l++) {
      part = ref[l];
      start = buffer.concat(part).join(path.sep);
      all = true;
      for (m = 0, len2 = files.length; m < len2; m++) {
        f = files[m];
        all && (all = f.filepath.indexOf(start) === 0);
      }
      if (all) {
        tokens[part] = buffer.push(part);
      } else {
        return buffer.join(path.sep);
      }
    }
  }
};

build_js_split = function(files, notify) {
  var base, buffer, file, filefolder, filename, folder, httpath, j, len, map, map64, output, paths;
  base = get_split_base_dir(files);
  paths = [];
  for (j = 0, len = files.length; j < len; j++) {
    file = files[j];
    filename = path.basename(file.filepath).replace(file.compiler.ext, '.js');
    filefolder = path.dirname(file.filepath);
    httpath = upath.join('__split__', filefolder.replace(base, ''), filename);
    output = upath.join(path.dirname(config.output.js), httpath);
    paths.push(output);
    buffer = file.wrapped;
    if (file.source_map != null) {
      file.source_map_offset = 1;
      map = sourcemaps.assemble([file]);
      map64 = sourcemaps.encode_base64(map);
      buffer += '\n';
      buffer += source_maps_header.replace('~MAP', map64);
    }
    folder = path.dirname(output);
    if (!fs.existsSync(folder)) {
      fsu.mkdir_p(folder);
    }
    fs.writeFileSync(output, buffer);
    if (notify) {
      exports.notify(output);
    }
  }
  return paths;
};

//# sourceMappingURL=compiler.js.map
