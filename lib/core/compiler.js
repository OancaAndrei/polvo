// Generated by CoffeeScript 1.6.3
var argv, auto_reload, build_js_split, compilers, config, debug, dirs, error, files, fs, fsu, get_split_base_dir, helpers_path, humanize, info, io_path, loader, loader_path, log_compiled, logger, minify, path, prefix, reloader_path, server, source_maps_header, sourcemaps, split_loader, split_loader_path, sufix, warn, zlib, _;

_ = require('lodash');

fs = require('fs');

zlib = require('zlib');

fsu = require('fs-util');

path = require('path');

humanize = require('humanize');

files = require('./files');

server = require('./server');

argv = require('../cli').argv;

dirs = require('../utils/dirs');

config = require('../utils/config');

minify = require('../utils/minify');

sourcemaps = require('../utils/sourcemaps');

logger = require('../utils/logger')('core/compiler');

error = logger.error, warn = logger.warn, info = logger.info, debug = logger.debug;

log_compiled = logger.file.compiled;

prefix = ";(function(){";

helpers_path = path.join(dirs.root, 'src', 'core', 'helpers');

loader_path = path.join(helpers_path, 'loader.js');

loader = fs.readFileSync(loader_path, 'utf-8');

loader = loader.replace('~ALIASES', JSON.stringify(config.alias));

split_loader_path = path.join(helpers_path, 'split.loader.js');

split_loader = fs.readFileSync(split_loader_path, 'utf-8');

io_path = path.join(dirs.root, 'node_modules', 'socket.io', 'node_modules');

io_path = path.join(io_path, 'socket.io-client', 'dist', 'socket.io.js');

reloader_path = loader_path.replace('loader.js', 'reloader.js');

auto_reload = fs.readFileSync(io_path, 'utf-8');

auto_reload += fs.readFileSync(reloader_path, 'utf-8');

source_maps_header = "/*\n//@ sourceMappingURL=data:application/json;charset=utf-8;base64,~MAP\n*/";

sufix = '})()';

compilers = {};

exports.build = function() {
  compilers = {};
  exports.build_js(true);
  return exports.build_css(true);
};

exports.release = function(done) {
  var after, js, jss, pending, uncompressed, _i, _len;
  jss = exports.build_js();
  exports.build_css();
  pending = 0;
  after = function() {
    if (--pending === 0) {
      return typeof done === "function" ? done() : void 0;
    }
  };
  if (config.minify.js) {
    for (_i = 0, _len = jss.length; _i < _len; _i++) {
      js = jss[_i];
      pending++;
      if (/__split__/.test(js)) {
        js = path.join(path.dirname(config.output.js), js);
      }
      uncompressed = fs.readFileSync(js);
      fs.writeFileSync(js, minify.js(uncompressed.toString()));
      exports.notify(js, after);
    }
  }
  if (config.minify.css) {
    pending++;
    uncompressed = fs.readFileSync(config.output.css);
    fs.writeFileSync(config.output.css, minify.css(uncompressed.toString()));
    return exports.notify(config.output.css, after);
  }
};

exports.build_js = function(notify) {
  var all, boot, buffer, comp, comp_name, each, helper, helpers, js, k, linesnum, merged, offset, split_paths, start, tmp, v, _i, _j, _len, _len1;
  files.files = _.sortBy(files.files, 'filepath');
  all = _.filter(files.files, {
    output: 'js'
  });
  if (!all.length) {
    return;
  }
  if (config.output.js == null) {
    error('JS not saved, you need to set the js output in your config file');
    return;
  }
  if (argv.split) {
    split_paths = build_js_split(all, notify);
  } else {
    split_paths = [];
  }
  helpers = {};
  merged = [];
  offset = 0;
  for (_i = 0, _len = all.length; _i < _len; _i++) {
    each = all[_i];
    if (each.is_partial) {
      continue;
    }
    js = each.wrapped;
    linesnum = js.split('\n').length;
    merged.push(js);
    each.source_map_offset = offset;
    offset += linesnum;
    comp = each.compiler;
    comp_name = comp.name;
    if ((helpers[comp_name] == null) && ((helper = typeof comp.fetch_helpers === "function" ? comp.fetch_helpers() : void 0) != null)) {
      helpers[comp_name] || (helpers[comp_name] = helper);
    }
  }
  helpers = (function() {
    var _results;
    _results = [];
    for (k in helpers) {
      v = helpers[k];
      _results.push(v);
    }
    return _results;
  })();
  merged = merged.join('\n');
  buffer = '';
  if (argv.server && !argv.release) {
    buffer += "\n// POLVO :: AUTORELOAD\n";
    buffer += auto_reload;
  }
  buffer += prefix;
  buffer += '\n// POLVO :: HELPERS\n';
  buffer += helpers;
  buffer += "\n// POLVO :: LOADER\n";
  buffer += loader;
  start = buffer.split('\n').length;
  for (_j = 0, _len1 = all.length; _j < _len1; _j++) {
    each = all[_j];
    each.source_map_offset += start;
  }
  sourcemaps.assemble(all);
  if (!argv.split) {
    buffer += "\n// POLVO :: MERGED FILES\n";
    buffer += merged;
  }
  buffer += "\n// POLVO :: INITIALIZER\n";
  boot = "require('" + config.boot + "');";
  if (argv.split) {
    tmp = split_loader.replace('~SRCS', JSON.stringify(split_paths));
    tmp = tmp.replace('~BOOT', boot);
    buffer += tmp;
  } else {
    buffer += boot;
  }
  if (!argv.split) {
    buffer += "\n";
    buffer += source_maps_header.replace('~MAP', sourcemaps.get_assembled_64());
  }
  buffer += sufix;
  fs.writeFileSync(config.output.js, buffer);
  if (!argv.release) {
    server.reload('js');
  }
  if (notify) {
    exports.notify(config.output.js);
  }
  return [config.output.js].concat(split_paths);
};

exports.build_css = function(notify) {
  var all, each, merged, _i, _len;
  files.files = _.sortBy(files.files, 'filepath');
  all = _.filter(files.files, {
    output: 'css'
  });
  if (!all.length) {
    return;
  }
  if (config.output.css == null) {
    error('CSS not saved, you need to set the css output in your config file');
    return;
  }
  merged = [];
  for (_i = 0, _len = all.length; _i < _len; _i++) {
    each = all[_i];
    if (each.is_partial) {
      continue;
    }
    merged.push(each.compiled);
  }
  merged = merged.join('\n');
  fs.writeFileSync(config.output.css, merged);
  server.reload('css');
  if (notify) {
    return exports.notify(config.output.css);
  }
};

exports.notify = function(filepath, done) {
  var fsize;
  fsize = humanize.filesize(fs.statSync(filepath).size);
  if (!argv.release) {
    log_compiled("" + filepath + " (" + fsize + ")");
    return typeof done === "function" ? done() : void 0;
  }
  return zlib.gzip(fs.readFileSync(filepath, 'utf-8'), function(err, gzip) {
    var gsize;
    fs.writeFileSync(filepath + '.tmp.gzip', gzip);
    gsize = humanize.filesize(fs.statSync(filepath + '.tmp.gzip').size);
    log_compiled("" + filepath + " (" + fsize + ") (" + gsize + " gzipped)");
    fs.unlinkSync(filepath + '.tmp.gzip');
    return typeof done === "function" ? done() : void 0;
  });
};

get_split_base_dir = function(files) {
  var all, buffer, f, file, part, start, tokens, _i, _j, _k, _len, _len1, _len2, _ref;
  buffer = [];
  tokens = {};
  for (_i = 0, _len = files.length; _i < _len; _i++) {
    file = files[_i];
    _ref = file.filepath.split(path.sep);
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      part = _ref[_j];
      if (tokens[part]) {
        continue;
      }
      start = buffer.concat(part).join(path.sep);
      all = true;
      for (_k = 0, _len2 = files.length; _k < _len2; _k++) {
        f = files[_k];
        all && (all = f.filepath.indexOf(start) === 0);
      }
      if (all) {
        tokens[part] = buffer.push(part);
      } else {
        return buffer.join(path.sep);
      }
    }
  }
};

build_js_split = function(files, notify) {
  var base, buffer, file, filefolder, filename, folder, httpath, map, map64, output, paths, _i, _len;
  base = get_split_base_dir(files);
  paths = [];
  for (_i = 0, _len = files.length; _i < _len; _i++) {
    file = files[_i];
    filename = path.basename(file.filepath).replace(file.compiler.ext, '.js');
    filefolder = path.dirname(file.filepath);
    httpath = path.join('/__split__', filefolder.replace(base, ''), filename);
    output = path.join(path.dirname(config.output.js), httpath);
    paths.push(httpath);
    buffer = file.wrapped;
    if (file.source_map != null) {
      map = JSON.parse(file.source_map);
      map.file = path.basename(output);
      map.sources = ['/' + dirs.relative(file.filepath)];
      map.sourcesContent = [file.raw];
      map64 = new Buffer(JSON.stringify(map)).toString('base64');
      buffer += '\n';
      buffer += source_maps_header.replace('~MAP', map64);
    }
    folder = path.dirname(output);
    if (!fs.existsSync(folder)) {
      fsu.mkdir_p(folder);
    }
    fs.writeFileSync(output, buffer);
    if (notify) {
      exports.notify(output);
    }
  }
  return paths;
};

/*
//@ sourceMappingURL=compiler.map
*/
